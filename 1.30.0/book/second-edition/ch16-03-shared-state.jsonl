{"question": "What is the difference between \"communicating by sharing memory\" and \"communicating by passing messages\"?", "answer": "Communicating by sharing memory allows multiple threads to access the same memory location at the same time, similar to multiple ownership. Communicating by passing messages is similar to single ownership, where a value is transferred down a channel and should no longer be used by the sender."}
{"question": "Why might message-passing enthusiasts prefer not to use shared memory concurrency?", "answer": "Shared memory concurrency can be complex to manage, as multiple threads need to coordinate access to the same data. Message passing can be simpler to reason about and implement."}
{"question": "What is a mutex, and what does it stand for?", "answer": "Mutex stands for mutual exclusion. A mutex is a concurrency primitive that allows only one thread to access some data at any given time."}
{"question": "How does a mutex work?", "answer": "A mutex guards data by using a lock. A thread must acquire the lock before accessing the data and release the lock when it is finished. This ensures that only one thread can access the data at a time."}
{"question": "What are the two rules for using a mutex?", "answer": "You must acquire the lock before using the data, and you must unlock the data when you are finished with it."}
{"question": "What is a real-world metaphor for a mutex?", "answer": "A panel discussion at a conference with only one microphone. Panelists must request the microphone before speaking and then pass it to the next panelist when they are finished."}
{"question": "How do you create a `Mutex<T>`?", "answer": "You use the associated function `new`."}
{"question": "How do you acquire the lock on a `Mutex<T>`?", "answer": "You call the `lock` method. This call will block the current thread until it can acquire the lock."}
{"question": "What happens if the call to `lock` fails?", "answer": "The call to `lock` will fail if another thread holding the lock panicked. In this case, the current thread will panic if it calls `unwrap`."}
{"question": "What type of reference does the `lock` method return?", "answer": "It returns a mutable reference to the data inside the mutex, wrapped in a smart pointer called `MutexGuard`."}
{"question": "How does `MutexGuard` ensure that the lock is released?", "answer": "It implements `Drop`, which automatically releases the lock when the `MutexGuard` goes out of scope."}
{"question": "What is the purpose of the `move` keyword in the closure passed to `thread::spawn`?", "answer": "The `move` keyword moves ownership of the `counter` variable into the closure, allowing the thread to access and modify the data."}
{"question": "Why does the code in Listing 16-13 fail to compile?", "answer": "The `counter` variable is moved into the closure for the first thread, preventing it from being captured by the closures for subsequent threads."}
{"question": "How can you fix the compiler error in Listing 16-13?", "answer": "You can use `Rc<T>` to create a reference-counted value that can be shared between multiple threads."}
{"question": "Why does the code in Listing 16-14 fail to compile?", "answer": "The `Rc<T>` type is not safe to share across threads because it does not use concurrency primitives to ensure thread-safe reference counting."}
{"question": "What is `Arc<T>`?", "answer": "It is an atomically reference counted type that is safe to use in concurrent situations. It is similar to `Rc<T>` but uses atomics to ensure thread-safe reference counting."}
{"question": "Why are not all primitive types atomic?", "answer": "Thread safety comes with a performance penalty, so atomics are only used when necessary. Primitive types are not atomic by default because they are often used in single-threaded contexts."}
{"question": "How does the code in Listing 16-15 fix the compiler errors?", "answer": "It uses `Arc<T>` to wrap the `Mutex<T>`, allowing the `Mutex<T>` to be shared safely across multiple threads."}
{"question": "What is the relationship between `RefCell<T>`/`Rc<T>` and `Mutex<T>`/`Arc<T>`?", "answer": "Both pairs provide interior mutability, allowing you to mutate data inside an immutable container. `RefCell<T>` is used with `Rc<T>` for single-threaded scenarios, while `Mutex<T>` is used with `Arc<T>` for multi-threaded scenarios."}
{"question": "What is a deadlock?", "answer": "A deadlock occurs when two threads each acquire a lock on a resource that the other thread needs, causing them to wait for each other indefinitely."}
{"question": "What are the `Send` and `Sync` traits?", "answer": "The `Send` trait indicates that a type can be safely sent between threads, while the `Sync` trait indicates that a type can be safely accessed from multiple threads."}