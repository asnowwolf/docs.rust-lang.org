{"question": "What are macros and how do they differ from functions?", "answer": "Macros are a way of writing code that writes other code, known as metaprogramming. They differ from functions in that they can take a variable number of parameters and are expanded before the compiler interprets the code, allowing them to perform actions like implementing traits at compile time. However, macros are more complex to define and maintain than functions."}
{"question": "What is the `#[macro_use]` annotation used for?", "answer": "The `#[macro_use]` annotation is used to bring macros defined in an external crate into the scope of your project."}
{"question": "What is the purpose of declarative macros?", "answer": "Declarative macros, also known as macros by example or `macro_rules!` macros, allow you to write code that resembles a Rust `match` expression, comparing the structure of Rust source code to patterns and replacing it with other code during compilation."}
{"question": "How does the `vec!` macro work?", "answer": "The `vec!` macro takes a variable number of expressions as arguments and generates code to create a new vector containing those elements. It uses a pattern to match the expressions and generates code to push each expression onto a new vector."}
{"question": "What is the purpose of procedural macros?", "answer": "Procedural macros are more like functions, accepting Rust code as input, operating on it, and producing new Rust code as output. They are currently used to allow traits to be implemented on a type by specifying the trait name in a `derive` annotation."}
{"question": "How do you define a procedural macro?", "answer": "Procedural macros are defined in a separate crate, typically named `foo_derive` for a crate named `foo`. The crate must be declared as a procedural macro crate and include dependencies on `syn` and `quote` for parsing and generating Rust code."}
{"question": "What is the role of the `proc_macro_derive` annotation?", "answer": "The `proc_macro_derive` annotation is used to define a procedural macro that implements a trait on a type when the `derive` annotation is used with the trait name."}
{"question": "What are the `syn` and `quote` crates used for?", "answer": "The `syn` crate parses Rust code from a string into a data structure, while the `quote` crate takes `syn` data structures and turns them back into Rust code. These crates simplify the process of parsing and generating Rust code in procedural macros."}
{"question": "What is the purpose of the `impl_hello_macro` function in the `hello_macro_derive` crate?", "answer": "The `impl_hello_macro` function generates the Rust code that implements the `HelloMacro` trait on the type annotated with `#[derive(HelloMacro)]`. It uses the `quote!` macro to create the implementation code."}
{"question": "What is the `stringify!` macro used for?", "answer": "The `stringify!` macro takes a Rust expression and converts it into a string literal at compile time, allowing you to represent the expression as a string without evaluating it."}
{"question": "What is the future of macros in Rust?", "answer": "Rust is expected to expand declarative and procedural macros in the future, introducing a new declarative macro system with the `macro` keyword and adding more types of procedural macros for more powerful tasks."}