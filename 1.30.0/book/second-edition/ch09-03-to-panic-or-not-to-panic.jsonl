{"question": "When should you call `panic!` instead of returning a `Result`?", "answer": "It's appropriate to call `panic!` in rare situations, such as examples, prototype code, and tests."}
{"question": "Why is it appropriate to call `panic!` in examples?", "answer": "Having robust error-handling code in examples can make them less clear. `panic!` acts as a placeholder for how your application would handle errors."}
{"question": "Why is it appropriate to call `panic!` in prototype code?", "answer": "The `unwrap` and `expect` methods are useful for prototyping, leaving clear markers for when you're ready to handle errors more robustly."}
{"question": "Why is it appropriate to call `panic!` in tests?", "answer": "If a method call fails in a test, you want the whole test to fail. `panic!` is how a test is marked as a failure, so calling `unwrap` or `expect` is appropriate."}
{"question": "When is it appropriate to call `unwrap` even though the compiler doesn't understand that failure is impossible?", "answer": "It's acceptable to call `unwrap` when you have logic that ensures the `Result` will have an `Ok` value, but the logic isn't something the compiler understands."}
{"question": "What are some examples of situations where it's appropriate to call `panic!`?", "answer": "It's advisable to panic when your code could end up in a bad state, such as when invalid, contradictory, or missing values are passed to your code, and the bad state is not expected, your code relies on not being in this bad state, and there's no good way to encode this information in the types you use."}
{"question": "What are some examples of situations where it's more appropriate to return a `Result` rather than `panic!`?", "answer": "When a bad state is expected to happen, such as a parser being given malformed data or an HTTP request returning a rate limit error, it's better to return a `Result` to propagate the bad state upward."}
{"question": "Why should you verify the validity of values before operating on them?", "answer": "Verifying values before operating on them is important for safety reasons. Attempting to operate on invalid data can expose your code to vulnerabilities."}
{"question": "What are contracts in functions, and how do they relate to `panic!`?", "answer": "Functions often have contracts, which are requirements for their inputs. Panicking when a contract is violated makes sense because it indicates a caller-side bug that needs to be fixed."}
{"question": "How can Rust's type system help with validation?", "answer": "Rust's type system can do many checks for you. If your function has a particular type as a parameter, you can proceed with your logic knowing that the compiler has already ensured you have a valid value."}
{"question": "How can you create a custom type for validation?", "answer": "You can define a new type and put the validations in a function to create an instance of the type, ensuring that only valid values can be used."}
{"question": "What is the purpose of the `Guess` type in Listing 9-9?", "answer": "The `Guess` type ensures that only values between 1 and 100 can be used, preventing invalid guesses in a guessing game."}
{"question": "Why is the `value` field of the `Guess` struct private?", "answer": "The `value` field is private to prevent code outside the module from setting it directly, ensuring that all `Guess` instances are created with valid values."}
{"question": "What is the purpose of the `value` method in the `Guess` struct?", "answer": "The `value` method is a getter that allows access to the `value` field of a `Guess` instance."}
{"question": "What are the benefits of using `panic!` and `Result` appropriately?", "answer": "Using `panic!` and `Result` appropriately makes your code more reliable by handling errors effectively and preventing the program from proceeding with invalid or incorrect values."}