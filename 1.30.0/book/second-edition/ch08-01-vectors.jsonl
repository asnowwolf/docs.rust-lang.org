{"question": "What is a vector in Rust?", "answer": "A vector, or `Vec<T>`, is a data structure that allows you to store multiple values of the same type in a single structure, with all values stored next to each other in memory."}
{"question": "What are vectors useful for?", "answer": "Vectors are useful for storing lists of items, such as lines of text in a file or prices in a shopping cart."}
{"question": "How do you create an empty vector?", "answer": "You can create an empty vector by calling the `Vec::new` function."}
{"question": "Why is a type annotation necessary when creating an empty vector?", "answer": "Because no values are inserted, Rust doesn't know what type of elements will be stored. Vectors are implemented using generics, and the `Vec<T>` type can hold any type. The specific type is specified within angle brackets."}
{"question": "How do you create a vector with initial values?", "answer": "You can use the `vec!` macro to create a new vector with initial values. The macro will infer the type of the vector based on the values provided."}
{"question": "How do you add elements to a vector?", "answer": "You can use the `push` method to add elements to a vector. The vector must be declared as mutable using the `mut` keyword."}
{"question": "What happens when a vector goes out of scope?", "answer": "When a vector goes out of scope, it is freed, and all of its elements are dropped."}
{"question": "How do you access elements in a vector?", "answer": "You can access elements in a vector using indexing syntax (`&v[2]`) or the `get` method (`v.get(2)`). Indexing syntax returns a reference, while the `get` method returns an `Option<&T>`."}
{"question": "What happens when you try to access an element that doesn't exist in a vector using indexing syntax?", "answer": "The program will panic."}
{"question": "What happens when you try to access an element that doesn't exist in a vector using the `get` method?", "answer": "The `get` method will return `None` without panicking."}
{"question": "Why can't you add an element to a vector while holding an immutable reference to an element?", "answer": "Adding an element to a vector might require allocating new memory and copying existing elements, which could invalidate the reference to the first element. The borrowing rules prevent this."}
{"question": "How do you iterate over the elements in a vector?", "answer": "You can use a `for` loop to iterate over the elements in a vector. You can get immutable references to each element using `&` or mutable references using `&mut`."}
{"question": "How do you change the value of an element in a vector while iterating over it?", "answer": "You need to use the dereference operator (`*`) to get to the value in the mutable reference before you can modify it."}
{"question": "How do you store values of different types in a vector?", "answer": "You can define an enum whose variants hold the different value types. Then, you can create a vector that holds the enum, effectively storing values of different types."}
{"question": "What are the advantages of using an enum to store values of different types in a vector?", "answer": "It allows Rust to know the types in the vector at compile time, ensuring correct memory allocation and preventing potential errors. It also enforces type safety by ensuring that all possible cases are handled."}
{"question": "What is an alternative to using an enum when you don't know the exhaustive set of types at runtime?", "answer": "You can use a trait object, which will be covered in Chapter 17."}