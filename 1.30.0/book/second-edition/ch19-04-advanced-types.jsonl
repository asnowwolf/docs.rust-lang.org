{"question": "What are some advanced types in Rust?", "answer": "Rust has advanced types such as newtypes, type aliases, the `!` type, and dynamically sized types."}
{"question": "What is the newtype pattern?", "answer": "The newtype pattern is a way to create a new type by wrapping an existing type in a struct. This can be used to enforce type safety, indicate units of a value, abstract away implementation details, and hide internal implementation."}
{"question": "How can the newtype pattern be used to enforce type safety?", "answer": "By wrapping a value in a newtype, you can prevent it from being used in functions that expect a different type. For example, you could create a `Millimeters` struct that wraps a `u32` value, and then a function that takes a `Millimeters` parameter could not be called with a `Meters` value or a plain `u32`."}
{"question": "How can the newtype pattern be used to indicate units of a value?", "answer": "You can create newtypes to represent different units of measurement, such as `Millimeters` and `Meters`, which both wrap a `u32` value. This helps to prevent accidental mixing of units."}
{"question": "How can the newtype pattern be used to abstract away implementation details?", "answer": "You can create a newtype that exposes a public API that is different from the API of the private inner type. This can be used to restrict the available functionality and hide implementation details."}
{"question": "How can the newtype pattern be used to hide internal implementation?", "answer": "You can create a newtype that wraps a data structure, such as a `HashMap`, and then provide a public API that only exposes the desired functionality. This hides the internal implementation details from users of the newtype."}
{"question": "What is a type alias?", "answer": "A type alias is a synonym for an existing type. It is created using the `type` keyword."}
{"question": "What is the difference between a newtype and a type alias?", "answer": "A newtype is a separate, new type, while a type alias is just a synonym for an existing type. Values of a newtype are treated differently from values of the original type, while values of a type alias are treated the same as values of the original type."}
{"question": "What is the main use case for type aliases?", "answer": "Type aliases are mainly used to reduce repetition in code, especially when dealing with long or complex types."}
{"question": "How can type aliases be used to reduce repetition?", "answer": "You can create a type alias for a long or complex type and then use the alias instead of the full type name throughout your code."}
{"question": "What is the `!` type?", "answer": "The `!` type, also known as the never type, is a special type that has no values. It is used as the return type of functions that never return."}
{"question": "What are diverging functions?", "answer": "Diverging functions are functions that never return. They have a return type of `!`."}
{"question": "How does the `!` type work with the `continue` keyword?", "answer": "The `continue` keyword has a `!` value, which means that it doesn't return a value. This allows `match` arms that end with `continue` to be used alongside arms that return a value, as long as the returned value is of the same type as the value returned by the other arms."}
{"question": "How does the `!` type work with the `panic!` macro?", "answer": "The `panic!` macro also has a `!` value, which means that it doesn't return a value. This allows functions that call `panic!` to have a return type that is not `!`."}
{"question": "What is a dynamically sized type?", "answer": "A dynamically sized type, or DST, is a type whose size is not known until runtime. This means that we cannot create variables of DSTs or take arguments of DSTs."}
{"question": "Why can't we create variables of DSTs?", "answer": "Rust needs to know how much memory to allocate for a value of a particular type, and all values of a type must use the same amount of memory. Since the size of a DST is not known until runtime, Rust cannot allocate memory for it."}
{"question": "How are DSTs used in Rust?", "answer": "DSTs are always used behind a pointer of some kind, such as a reference (`&T`) or a box (`Box<T>`). The pointer stores the address of the DST and its size, allowing Rust to know the size of the pointer at compile time."}
{"question": "What is the `Sized` trait?", "answer": "The `Sized` trait is a special trait that is automatically implemented for all types whose size is known at compile time. It is used to determine whether or not a type is a DST."}
{"question": "How does the `Sized` trait affect generic functions?", "answer": "Generic functions implicitly have a bound on `Sized`, which means that they can only work on types whose size is known at compile time. However, you can use the `?Sized` trait bound to relax this restriction and allow generic functions to work on DSTs."}
{"question": "What is the `?Sized` trait bound?", "answer": "The `?Sized` trait bound is the opposite of the `Sized` trait bound. It means that the type may or may not be `Sized`. It is only available for the `Sized` trait."}
{"question": "Why do we need to use a pointer when working with DSTs?", "answer": "Because the size of a DST is not known until runtime, we need to use a pointer to store the address of the DST and its size. This allows Rust to know the size of the pointer at compile time."}