{"question": "What is the `match` control flow operator in Rust?", "answer": "The `match` operator allows you to compare a value against a series of patterns and execute code based on which pattern matches."}
{"question": "What are patterns in Rust?", "answer": "Patterns can be made up of literal values, variable names, wildcards, and many other things."}
{"question": "What is the benefit of using `match`?", "answer": "The power of `match` comes from the expressiveness of the patterns and the fact that the compiler confirms that all possible cases are handled."}
{"question": "How does `match` work?", "answer": "Think of a `match` expression as being like a coin-sorting machine: coins slide down a track with variously sized holes along it, and each coin falls through the first hole it encounters that it fits into. In the same way, values go through each pattern in a `match`, and at the first pattern the value “fits,” the value falls into the associated code block to be used during execution."}
{"question": "What is a `match` arm?", "answer": "An arm has two parts: a pattern and some code. The first arm here has a pattern that is the value `Coin::Penny` and then the `=>` operator that separates the pattern and the code to run. The code in this case is just the value `1`."}
{"question": "How does the `match` expression execute?", "answer": "When the `match` expression executes, it compares the resulting value against the pattern of each arm, in order. If a pattern matches the value, the code associated with that pattern is executed. If that pattern doesn’t match the value, execution continues to the next arm."}
{"question": "What is the return value of a `match` expression?", "answer": "The code associated with each arm is an expression, and the resulting value of the expression in the matching arm is the value that gets returned for the entire `match` expression."}
{"question": "How can I run multiple lines of code in a match arm?", "answer": "If you want to run multiple lines of code in a match arm, you can use curly brackets."}
{"question": "How can I bind a variable to the parts of the values that match the pattern?", "answer": "Match arms can bind to the parts of the values that match the pattern. This is how we can extract values out of enum variants."}
{"question": "How can I handle `Option<T>` using `match`?", "answer": "Instead of comparing coins, we’ll compare the variants of `Option<T>`, but the way that the `match` expression works remains the same."}
{"question": "What happens if a `match` expression doesn't cover all possible cases?", "answer": "Rust knows that we didn’t cover every possible case and even knows which pattern we forgot! Matches in Rust are *exhaustive*: we must exhaust every last possibility in order for the code to be valid."}
{"question": "What is the `_` placeholder?", "answer": "The `_` pattern will match any value. By putting it after our other arms, the `_` will match all the possible cases that aren’t specified before it."}