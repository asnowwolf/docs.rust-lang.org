{"question": "What are closures in Rust?", "answer": "Closures are anonymous functions that can be saved in a variable or passed as arguments to other functions. They can capture values from the scope in which they are defined."}
{"question": "What is the syntax for defining a closure in Rust?", "answer": "Closures are defined using vertical pipes (`|`) to enclose the parameters, followed by curly brackets (`{}`) for the body. The body is optional if the closure has only one expression."}
{"question": "How do you call a closure in Rust?", "answer": "You call a closure like a function, by specifying the variable name that holds the closure definition followed by parentheses containing the argument values."}
{"question": "Why don't closures require type annotations for parameters and return values?", "answer": "Closures are typically short and used in limited contexts, allowing the compiler to infer the types reliably. Type annotations are optional but can be added for clarity."}
{"question": "What are the three `Fn` traits that closures implement?", "answer": "The three `Fn` traits are `FnOnce`, `FnMut`, and `Fn`. They represent different ways a closure can capture values from its environment: `FnOnce` consumes the values, `FnMut` mutably borrows them, and `Fn` immutably borrows them."}
{"question": "How does Rust infer which `Fn` trait a closure implements?", "answer": "Rust infers the trait based on how the closure uses the values from its environment. All closures implement `FnOnce`, closures that don't move captured variables implement `FnMut`, and closures that don't need mutable access to captured variables implement `Fn`."}
{"question": "What is the purpose of the `move` keyword in a closure definition?", "answer": "The `move` keyword forces the closure to take ownership of the values it uses from its environment. This is useful when passing a closure to a new thread to move the data into the new thread's ownership."}
{"question": "What is the `Cacher` struct used for?", "answer": "The `Cacher` struct holds a closure and an optional result value. It executes the closure only when needed and caches the result to avoid repeated execution."}
{"question": "What are the limitations of the `Cacher` implementation in the example?", "answer": "The `Cacher` implementation assumes the same value will always be passed to the `value` method, and it only accepts closures with one `u32` parameter and a `u32` return value."}
{"question": "How can you improve the `Cacher` implementation to address these limitations?", "answer": "You can use a hash map to store results for different `arg` values, and introduce more generic parameters to increase flexibility."}