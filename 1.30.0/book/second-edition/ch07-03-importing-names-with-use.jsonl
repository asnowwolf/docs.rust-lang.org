{"question": "How can I call a function defined within a module using the module name?", "answer": "You can call the function by specifying the full path to the function, including the module name, as in `a::series::of::nested_modules()`."}
{"question": "What is the purpose of the `use` keyword in Rust?", "answer": "The `use` keyword brings modules or functions into scope, allowing you to refer to them more concisely without having to specify the full path."}
{"question": "How do I bring the `a::series::of` module into the root scope of a binary crate?", "answer": "Use the statement `use a::series::of;`."}
{"question": "Does the `use` keyword bring all children of a module into scope?", "answer": "No, the `use` keyword only brings the specified module or item into scope. You still need to specify the full path to access children of the module."}
{"question": "How can I bring a function directly into scope without specifying the module path?", "answer": "Use the statement `use a::series::of::nested_modules;`."}
{"question": "How can I bring multiple items from a namespace into scope?", "answer": "Use curly brackets and commas to list the items in the `use` statement, like `use TrafficLight::{Red, Yellow};`."}
{"question": "How can I bring all items in a namespace into scope?", "answer": "Use the `*` operator, also known as the glob operator, in the `use` statement, like `use TrafficLight::*;`."}
{"question": "What is the glob operator and what are its potential drawbacks?", "answer": "The glob operator (`*`) brings all visible items in a namespace into scope. While convenient, it can bring in more items than expected and lead to naming conflicts."}
{"question": "How can I access a parent module from a nested module?", "answer": "Use the `super` keyword to move up one level in the module hierarchy, like `super::client::connect();`."}
{"question": "What is the purpose of the `tests` module in a library crate?", "answer": "The `tests` module is used for writing tests to exercise the code within the library."}
{"question": "Why can't I directly call `client::connect()` from the `tests` module?", "answer": "The `tests` module is a separate module, and paths are relative to the current module. You need to bring the `client` module into scope within the `tests` module."}
{"question": "What are the two ways to access a sibling module from a nested module?", "answer": "You can either use leading colons to specify the full path from the root, like `::client::connect();`, or use `super` to move up one level in the hierarchy, like `super::client::connect();`."}
{"question": "Why is using `super` generally preferred over specifying the full path from the root?", "answer": "Using `super` is more concise and avoids needing to update multiple paths if you rearrange your modules."}
{"question": "How can I avoid having to type `super::` in every test?", "answer": "Use the `use` keyword with `super` to bring the desired module into scope, like `use super::client;`."}
{"question": "What are some benefits of organizing code into modules?", "answer": "Modules help group related functionality, prevent files from becoming too long, and present a clean public API to library users."}