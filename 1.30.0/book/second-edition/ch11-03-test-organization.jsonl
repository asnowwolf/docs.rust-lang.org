{"question": "What are the two main categories of tests in the Rust community?", "answer": "The two main categories of tests are unit tests and integration tests."}
{"question": "What is the purpose of unit tests?", "answer": "Unit tests are small and focused, testing one module in isolation at a time, and can test private interfaces. They are used to quickly pinpoint where code is and isn't working as expected."}
{"question": "Where are unit tests placed in a Rust project?", "answer": "Unit tests are placed in the *src* directory in each file with the code that they're testing."}
{"question": "What is the convention for creating a module for unit tests?", "answer": "The convention is to create a module named `tests` in each file to contain the test functions."}
{"question": "What is the purpose of the `#[cfg(test)]` annotation?", "answer": "The `#[cfg(test)]` annotation tells Rust to compile and run the test code only when you run `cargo test`, not when you run `cargo build`."}
{"question": "Why is the `#[cfg(test)]` annotation used for unit tests?", "answer": "It saves compile time when you only want to build the library and saves space in the resulting compiled artifact because the tests are not included."}
{"question": "What is the purpose of integration tests?", "answer": "Integration tests are entirely external to your library and use your code in the same way any other external code would, using only the public interface and potentially exercising multiple modules per test. They are used to test whether many parts of your library work together correctly."}
{"question": "Where are integration tests placed in a Rust project?", "answer": "Integration tests are placed in a *tests* directory at the top level of the project directory, next to *src*."}
{"question": "How do you import a library into an integration test file?", "answer": "You use the `extern crate` keyword followed by the name of the library."}
{"question": "What is the purpose of the *tests* directory?", "answer": "Cargo knows to look for integration test files in this directory. Each file in the *tests* directory is compiled as an individual crate."}
{"question": "What is the purpose of the `#[cfg(test)]` annotation for integration tests?", "answer": "It is not needed for integration tests because Cargo treats the `tests` directory specially and compiles files in this directory only when we run `cargo test`."}
{"question": "How can you run a particular integration test function?", "answer": "You can specify the test function's name as an argument to `cargo test`."}
{"question": "How can you run all the tests in a particular integration test file?", "answer": "You can use the `--test` argument of `cargo test` followed by the name of the file."}
{"question": "What is the purpose of submodules in integration tests?", "answer": "Submodules can be used to organize integration tests by functionality, grouping test functions together."}
{"question": "Why is it important to use the naming convention *module_name/mod.rs* for files of modules that have submodules in the *tests* directory?", "answer": "This tells Rust not to treat the module as an integration test file, preventing it from appearing in the test output."}
{"question": "How can you call a function from a submodule in an integration test file?", "answer": "You can use the module name followed by the function name, separated by a double colon."}
{"question": "Why can't you create integration tests for binary crates in the *tests* directory and use `extern crate` to import functions defined in the *src/main.rs* file?", "answer": "Only library crates expose functions that other crates can call and use; binary crates are meant to be run on their own."}
{"question": "What is the recommended structure for Rust projects that provide a binary?", "answer": "They should have a straightforward *src/main.rs* file that calls logic that lives in the *src/lib.rs* file. This allows integration tests to test the library crate by using `extern crate`."}
{"question": "What is the purpose of testing in Rust?", "answer": "Testing is used to specify how code should function to ensure it continues to work as expected, even as you make changes."}
{"question": "What are the benefits of unit tests?", "answer": "Unit tests exercise different parts of a library separately and can test private implementation details."}
{"question": "What are the benefits of integration tests?", "answer": "Integration tests check that many parts of the library work together correctly, and they use the library's public API to test the code in the same way external code will use it."}