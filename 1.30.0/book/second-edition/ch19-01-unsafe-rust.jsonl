{"question": "What is unsafe Rust?", "answer": "Unsafe Rust is a subset of Rust that allows you to perform operations that are not memory safe, such as dereferencing raw pointers or calling unsafe functions."}
{"question": "Why does Rust have unsafe Rust?", "answer": "Unsafe Rust exists because static analysis is conservative, and the compiler might reject valid programs to avoid accepting invalid ones. It also allows for low-level systems programming, such as interacting with the operating system or writing your own operating system."}
{"question": "What are the four unsafe superpowers?", "answer": "The four unsafe superpowers are: dereferencing a raw pointer, calling an unsafe function or method, accessing or modifying a mutable static variable, and implementing an unsafe trait."}
{"question": "Does the `unsafe` keyword disable all of Rust's safety checks?", "answer": "No, the `unsafe` keyword only gives you access to the four unsafe superpowers. Other safety checks, such as the borrow checker, are still enforced."}
{"question": "What is a raw pointer?", "answer": "A raw pointer is a type similar to a reference, but it does not have the same safety guarantees. It can be immutable or mutable, and is written as `*const T` and `*mut T`, respectively."}
{"question": "What are the differences between raw pointers and references?", "answer": "Raw pointers can ignore the borrowing rules, are not guaranteed to point to valid memory, can be null, and do not implement automatic cleanup."}
{"question": "How do you create a raw pointer from a reference?", "answer": "You can use the `as` keyword to cast a reference to its corresponding raw pointer type."}
{"question": "How do you dereference a raw pointer?", "answer": "You must use the dereference operator `*` within an `unsafe` block."}
{"question": "What is an unsafe function?", "answer": "An unsafe function is a function that has an `unsafe` keyword before its definition. It indicates that the function has requirements that the compiler cannot verify, and the programmer must ensure that these requirements are met."}
{"question": "How do you call an unsafe function?", "answer": "You must call an unsafe function within an `unsafe` block."}
{"question": "What is a safe abstraction over unsafe code?", "answer": "A safe abstraction is a function or method that wraps unsafe code and provides a safe interface to it. This allows users to use the functionality without having to deal with the unsafe code directly."}
{"question": "What is the `split_at_mut` function?", "answer": "The `split_at_mut` function takes a mutable slice and splits it into two slices at a given index."}
{"question": "Why can't the `split_at_mut` function be implemented using only safe Rust?", "answer": "The borrow checker cannot understand that the two slices created by `split_at_mut` are not overlapping, so it will prevent the function from compiling."}
{"question": "How does the `split_at_mut` function use unsafe code?", "answer": "It uses the `slice::from_raw_parts_mut` function, which takes a raw pointer and a length and creates a slice. It also uses the `offset` method on raw pointers, which is also unsafe."}
{"question": "What is the `extern` keyword?", "answer": "The `extern` keyword is used to create a Foreign Function Interface (FFI), which allows Rust code to interact with code written in other languages."}
{"question": "What is an ABI?", "answer": "An ABI (Application Binary Interface) defines how to call a function at the assembly level."}
{"question": "Why are functions declared within `extern` blocks always unsafe?", "answer": "Other languages do not enforce Rust's rules and guarantees, so Rust cannot check them. The programmer must ensure safety when calling these functions."}
{"question": "What is a static variable?", "answer": "A static variable is a global variable in Rust. It can be immutable or mutable."}
{"question": "What is the difference between a constant and a static variable?", "answer": "A static variable has a fixed address in memory, while a constant can duplicate its data whenever it is used. Static variables can be mutable, while constants cannot."}
{"question": "Why is accessing or modifying a mutable static variable unsafe?", "answer": "It can lead to data races if multiple threads access the same variable."}
{"question": "What is an unsafe trait?", "answer": "An unsafe trait is a trait that has at least one method with an invariant that the compiler cannot verify."}
{"question": "How do you implement an unsafe trait?", "answer": "You must use the `unsafe impl` keyword to indicate that you are taking responsibility for upholding the invariants that the compiler cannot verify."}
{"question": "When should you use unsafe code?", "answer": "You should use unsafe code only when you have a specific reason to do so, such as interfacing with C code or building safe abstractions that the borrow checker cannot understand."}