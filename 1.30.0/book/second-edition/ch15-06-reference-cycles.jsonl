{"question": "What is a memory leak in Rust?", "answer": "A memory leak is memory that is never cleaned up, meaning it remains allocated even after it is no longer needed."}
{"question": "How can reference cycles lead to memory leaks in Rust?", "answer": "Reference cycles occur when objects refer to each other in a circular manner, preventing the reference count of each object from reaching zero, thus preventing them from being dropped."}
{"question": "What is the purpose of the `RefCell<T>` type in the `List` enum?", "answer": "The `RefCell<T>` type allows us to modify the `List` value that a `Cons` variant is pointing to, providing mutability within an immutable context."}
{"question": "What is the purpose of the `tail` method in the `List` enum?", "answer": "The `tail` method provides a convenient way to access the second item (the `RefCell<Rc<List>>`) of a `Cons` variant."}
{"question": "How is a reference cycle created in Listing 15-26?", "answer": "A reference cycle is created by first creating two `List` values, `a` and `b`, where `b` points to `a`. Then, `a` is modified to point to `b`, creating a circular reference."}
{"question": "What is the purpose of the `Rc::downgrade` function?", "answer": "The `Rc::downgrade` function creates a `Weak<T>` reference to the value within an `Rc<T>` instance, which does not increase the `strong_count` but increases the `weak_count`."}
{"question": "What is the difference between a strong reference and a weak reference?", "answer": "A strong reference increases the `strong_count` of an `Rc<T>` instance, while a weak reference increases the `weak_count` and does not affect the `strong_count`. Strong references express ownership, while weak references do not."}
{"question": "How does the `Weak<T>` type prevent reference cycles?", "answer": "Weak references do not prevent the creation of cycles, but they do not contribute to the `strong_count` of the referenced object. Therefore, if all strong references to an object are dropped, the object will be dropped even if there are weak references to it."}
{"question": "What is the purpose of the `upgrade` method on a `Weak<T>` instance?", "answer": "The `upgrade` method attempts to convert a `Weak<T>` reference into an `Rc<T>` reference. It returns `Some(Rc<T>)` if the referenced object still exists and `None` if it has been dropped."}
{"question": "What is the purpose of the `parent` field in the `Node` struct?", "answer": "The `parent` field allows a child node to refer to its parent node using a `Weak<Node>` reference, preventing reference cycles."}
{"question": "Why is the `parent` field in the `Node` struct a `RefCell<Weak<Node>>`?", "answer": "The `RefCell<T>` allows us to modify the `Weak<Node>` reference within the `parent` field, while the `Weak<Node>` ensures that the child node does not own its parent."}
{"question": "How does the code in Listing 15-29 demonstrate the difference between strong and weak references?", "answer": "By creating `branch` within an inner scope, the code shows that when `branch` goes out of scope, its `Rc<Node>` is dropped because its `strong_count` reaches zero, even though there is a `Weak<Node>` reference to it from `leaf.parent`."}
{"question": "What are the key takeaways from this chapter regarding smart pointers?", "answer": "Smart pointers provide ways to manage memory and ownership in Rust, offering different guarantees and trade-offs compared to regular references. `Box<T>` allocates data on the heap, `Rc<T>` allows multiple owners, and `RefCell<T>` provides interior mutability. The `Deref` and `Drop` traits enable the functionality of smart pointers. Reference cycles can cause memory leaks, and `Weak<T>` can be used to prevent them."}