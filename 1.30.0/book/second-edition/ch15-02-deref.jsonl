{"question": "What does implementing the `Deref` trait allow you to do?", "answer": "Implementing the `Deref` trait allows you to customize the behavior of the dereference operator, `*`, and make a smart pointer behave like a regular reference."}
{"question": "How does the dereference operator work with regular references?", "answer": "The dereference operator, `*`, follows a reference to the data it points to."}
{"question": "What is the difference between using a reference and a `Box<T>` when using the dereference operator?", "answer": "Both references and `Box<T>` can be dereferenced using the `*` operator to access the value they point to."}
{"question": "Why doesn't the dereference operator work with a custom `MyBox<T>` type by default?", "answer": "The `MyBox<T>` type doesn't have the `Deref` trait implemented, so Rust doesn't know how to dereference it."}
{"question": "How do you implement the `Deref` trait for a custom type like `MyBox<T>`?", "answer": "You need to define a `deref` method that borrows `self` and returns a reference to the inner data."}
{"question": "What does the `type Target = T;` syntax do in the `Deref` implementation?", "answer": "It defines an associated type for the `Deref` trait, specifying the type that the `deref` method returns a reference to."}
{"question": "What happens behind the scenes when you use the `*` operator on a type that implements `Deref`?", "answer": "Rust substitutes the `*` operator with a call to the `deref` method and then a plain dereference."}
{"question": "Why does the `deref` method return a reference to the value instead of the value itself?", "answer": "Returning a reference prevents the value from being moved out of `self`, preserving ownership."}
{"question": "What is deref coercion?", "answer": "Deref coercion is a feature that automatically converts a reference to a type that implements `Deref` into a reference to the type that `Deref` can convert the original type into."}
{"question": "How does deref coercion work with functions and methods?", "answer": "When a function or method expects a specific type, deref coercion can convert the argument to that type by calling the `deref` method as many times as necessary."}
{"question": "What are the three cases where deref coercion happens?", "answer": "Deref coercion happens from `&T` to `&U` when `T: Deref<Target=U>`, from `&mut T` to `&mut U` when `T: DerefMut<Target=U>`, and from `&mut T` to `&U` when `T: Deref<Target=U>`."}
{"question": "Why can a mutable reference be coerced to an immutable reference, but not the other way around?", "answer": "Because of the borrowing rules, a mutable reference must be the only reference to the data, while an immutable reference doesn't have this restriction."}