{"question": "What is a process?", "answer": "A process is a unit of execution for a program in an operating system."}
{"question": "What are threads?", "answer": "Threads are independent parts of a program that can run simultaneously within a process."}
{"question": "What are the benefits of using threads?", "answer": "Threads can improve performance by allowing a program to perform multiple tasks at the same time."}
{"question": "What are the potential problems with using threads?", "answer": "Threads can introduce complexity and potential problems such as race conditions, deadlocks, and bugs that are difficult to reproduce and fix."}
{"question": "How does Rust attempt to mitigate the negative effects of using threads?", "answer": "Rust attempts to mitigate the negative effects of using threads, but programming in a multithreaded context still takes careful thought and requires a code structure that is different from that in programs running in a single thread."}
{"question": "What are the two main models for implementing threads in programming languages?", "answer": "The two main models are 1:1 threading and green threading."}
{"question": "What is 1:1 threading?", "answer": "1:1 threading is a model where a language calls the operating system APIs to create threads, resulting in one operating system thread per one language thread."}
{"question": "What is green threading?", "answer": "Green threading is a model where a programming language provides its own implementation of threads, known as green threads, which are executed in the context of a different number of operating system threads."}
{"question": "What is the M:N model of green threading?", "answer": "The M:N model of green threading means that there are `M` green threads per `N` operating system threads, where `M` and `N` are not necessarily the same number."}
{"question": "What is the trade-off between 1:1 threading and green threading?", "answer": "The main trade-off is runtime support. Green threading requires a larger language runtime to manage threads, while 1:1 threading has a smaller runtime."}
{"question": "Why does Rust use 1:1 threading?", "answer": "Rust uses 1:1 threading because it needs to have nearly no runtime and cannot compromise on being able to call into C to maintain performance."}
{"question": "How do you create a new thread in Rust?", "answer": "You can create a new thread by calling the `thread::spawn` function and passing it a closure containing the code you want to run in the new thread."}
{"question": "What is a `JoinHandle`?", "answer": "A `JoinHandle` is an owned value that, when you call the `join` method on it, will wait for its thread to finish."}
{"question": "How do you ensure that a spawned thread finishes before the main thread exits?", "answer": "You can save the return value of `thread::spawn` in a variable of type `JoinHandle` and then call `join` on the handle."}
{"question": "What is a `move` closure?", "answer": "A `move` closure is a closure that takes ownership of the values it uses in the environment."}
{"question": "Why is the `move` keyword often used with `thread::spawn`?", "answer": "The `move` keyword is often used with `thread::spawn` because it allows you to use data from one thread in another thread."}
{"question": "What happens when you use a `move` closure with `thread::spawn`?", "answer": "When you use a `move` closure with `thread::spawn`, the closure takes ownership of the values it uses, transferring ownership of those values from the main thread to the spawned thread."}
{"question": "What happens if you try to use a value in the main thread that has been moved to a spawned thread using a `move` closure?", "answer": "You will get a compiler error because you are trying to use a value that has already been moved."}