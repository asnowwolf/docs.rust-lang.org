{"question": "What is `Rc<T>` and what is it used for?", "answer": "The `Rc<T>` type is a reference-counted smart pointer that allows multiple owners of a value. It keeps track of the number of references to a value and cleans up the value when there are zero references left."}
{"question": "What is an analogy for `Rc<T>`?", "answer": "Imagine `Rc<T>` as a TV in a family room. When one person enters to watch TV, they turn it on. Others can come into the room and watch the TV. When the last person leaves the room, they turn off the TV because it’s no longer being used."}
{"question": "When is `Rc<T>` useful?", "answer": "It is useful when you want to allocate data on the heap for multiple parts of your program to read and you can’t determine at compile time which part will finish using the data last."}
{"question": "Why is `Rc<T>` only for use in single-threaded scenarios?", "answer": "The `Rc<T>` type is not thread-safe. We will discuss how to do reference counting in multithreaded programs in Chapter 16."}
{"question": "What is the problem with using `Box<T>` to share data between multiple lists?", "answer": "When you move a `Box<T>` into a new list, the original list loses ownership of the data. This means you can't use the original list again."}
{"question": "Why can't we use references to share data between lists?", "answer": "References require lifetime parameters, which would force every element in the list to live at least as long as the entire list. This is not always possible."}
{"question": "How does `Rc<T>` solve the problem of sharing data between lists?", "answer": "Each `Cons` variant holds a value and an `Rc<T>` pointing to a `List`. When you create a new list, you clone the `Rc<List>` from the original list, increasing the reference count and allowing both lists to share ownership of the data."}
{"question": "What is the difference between `Rc::clone` and `a.clone()`?", "answer": "Both methods increase the reference count. However, `Rc::clone` is the preferred method because it visually distinguishes between deep-copy clones and reference-count increases."}
{"question": "How does `Rc::strong_count` work?", "answer": "It returns the number of strong references to the data within the `Rc<T>`."}
{"question": "What happens when an `Rc<T>` goes out of scope?", "answer": "The reference count is automatically decreased. When the reference count reaches zero, the data is cleaned up."}
{"question": "Why can't `Rc<T>` allow multiple mutable references?", "answer": "It would violate the borrowing rules and could lead to data races and inconsistencies."}
{"question": "What is the interior mutability pattern and how does it relate to `Rc<T>`?", "answer": "The interior mutability pattern allows you to mutate data within an immutable container. The `RefCell<T>` type can be used in conjunction with `Rc<T>` to achieve this."}