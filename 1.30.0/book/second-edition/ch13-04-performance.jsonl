{"question": "How do you determine whether to use loops or iterators in Rust?", "answer": "You need to know which version is faster: the version with an explicit `for` loop or the version with iterators."}
{"question": "What was the result of the benchmark comparing the `for` loop and iterator versions of the `search` function?", "answer": "The iterator version was slightly faster."}
{"question": "What is the purpose of the benchmark comparing the `for` loop and iterator versions of the `search` function?", "answer": "The purpose is not to prove that the two versions are equivalent, but to get a general sense of how these two implementations compare performance-wise."}
{"question": "What is the key takeaway from the benchmark comparing the `for` loop and iterator versions of the `search` function?", "answer": "Iterators, although a high-level abstraction, get compiled down to roughly the same code as if you’d written the lower-level code yourself."}
{"question": "What is a zero-cost abstraction?", "answer": "A zero-cost abstraction is an abstraction that imposes no additional runtime overhead."}
{"question": "What is an example of a zero-cost abstraction in Rust?", "answer": "Iterators are an example of a zero-cost abstraction in Rust."}
{"question": "What is the zero-overhead principle?", "answer": "The zero-overhead principle states that what you don’t use, you don’t pay for, and what you do use, you couldn’t hand code any better."}
{"question": "What is an example of how Rust translates high-level ideas to low-level code?", "answer": "The code example provided, taken from an audio decoder, uses an iterator chain to do some math on three variables in scope: a `buffer` slice of data, an array of 12 `coefficients`, and an amount by which to shift data in `qlp_shift`."}
{"question": "What is the purpose of the code example provided, taken from an audio decoder?", "answer": "The code example demonstrates how Rust translates high-level ideas to low-level code."}
{"question": "What is the result of compiling the code example provided, taken from an audio decoder?", "answer": "The code compiles down to the same assembly you’d write by hand."}
{"question": "What is unrolling?", "answer": "Unrolling is an optimization that removes the overhead of the loop controlling code and instead generates repetitive code for each iteration of the loop."}
{"question": "What are the benefits of unrolling?", "answer": "Unrolling makes the resulting code extremely efficient by removing the overhead of the loop controlling code and generating repetitive code for each iteration of the loop."}
{"question": "What are the benefits of using iterators and closures in Rust?", "answer": "Iterators and closures make code seem like it’s higher level but don’t impose a runtime performance penalty for doing so."}
{"question": "What is the main takeaway from this section?", "answer": "Closures and iterators are Rust features inspired by functional programming language ideas. They contribute to Rust’s capability to clearly express high-level ideas at low-level performance. The implementations of closures and iterators are such that runtime performance is not affected. This is part of Rust’s goal to strive to provide zero-cost abstractions."}