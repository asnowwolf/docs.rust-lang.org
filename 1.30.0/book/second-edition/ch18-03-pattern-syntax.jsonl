{"question": "What are patterns in Rust?", "answer": "Patterns are a way to match values against different structures and extract data from them."}
{"question": "How can you match literals in Rust?", "answer": "You can match patterns against literals directly, for example, `match x { 1 => println!(\"one\"), _ => println!(\"anything\"), }`."}
{"question": "What happens when you use named variables in a `match` expression?", "answer": "Variables declared as part of a pattern inside the `match` expression will shadow those with the same name outside the `match` construct."}
{"question": "How can you match multiple patterns in a `match` expression?", "answer": "You can use the `|` syntax, which means *or*, for example, `match x { 1 | 2 => println!(\"one or two\"), _ => println!(\"anything\"), }`."}
{"question": "What is the `...` syntax used for in patterns?", "answer": "The `...` syntax allows you to match an inclusive range of values, for example, `match x { 1 ... 5 => println!(\"one through five\"), _ => println!(\"something else\"), }`."}
{"question": "What types can be used with the `...` syntax?", "answer": "Ranges are only allowed with numeric values or `char` values because the compiler checks that the range isn't empty at compile time."}
{"question": "How can you destructure structs in patterns?", "answer": "You can use a pattern with a `let` statement to break apart the fields of a struct, for example, `let Point { x: a, y: b } = p;`."}
{"question": "What is the shorthand for destructuring struct fields?", "answer": "You can simply list the name of the struct field, and the variables created from the pattern will have the same names, for example, `let Point { x, y } = p;`."}
{"question": "How can you destructure enums in patterns?", "answer": "The pattern to destructure an enum should correspond to the way the data stored within the enum is defined. For example, `match msg { Message::Quit => println!(\"The Quit variant has no data to destructure.\"), Message::Move { x, y } => println!(\"Move in the x direction {} and in the y direction {}\", x, y), _ => (), }`."}
{"question": "How can you destructure references in patterns?", "answer": "You can specify a `&` in the pattern to get a variable holding the value that the reference points to rather than getting a variable that holds the reference."}
{"question": "How can you ignore values in a pattern?", "answer": "You can use the `_` pattern, the `_` pattern within another pattern, a name that starts with an underscore, or `..` to ignore remaining parts of a value."}
{"question": "What is the difference between using `_` and a name that starts with an underscore in patterns?", "answer": "The syntax `_x` still binds the value to the variable, whereas `_` doesn’t bind at all."}
{"question": "What is the `..` syntax used for in patterns?", "answer": "The `..` syntax ignores any parts of a value that we haven’t explicitly matched in the rest of the pattern."}
{"question": "How can you create references in patterns?", "answer": "You can use the `ref` keyword before the new variable to create a reference in a pattern."}
{"question": "How can you create mutable references in patterns?", "answer": "You can use `ref mut` instead of `&mut` to create a mutable reference in a pattern."}
{"question": "What are match guards?", "answer": "Match guards are additional `if` conditions specified after the pattern in a `match` arm that must also match, along with the pattern matching, for that arm to be chosen."}
{"question": "How can you use match guards to test for equality with an outer variable?", "answer": "You can use a match guard to test for equality with an outer variable by specifying a pattern that doesn't shadow the outer variable and then using the outer variable in the match guard."}
{"question": "What is the precedence of combining a match guard with a pattern that uses `|`?", "answer": "The `if` condition applies to the whole pattern, not only to the last value in the list of values specified using the `|` operator."}
{"question": "What is the `@` operator used for in patterns?", "answer": "The `@` operator lets us create a variable that holds a value at the same time we’re testing that value to see whether it matches a pattern."}
{"question": "What are the benefits of using patterns in Rust?", "answer": "Patterns help distinguish between different kinds of data, ensure that your patterns cover every possible value in `match` expressions, and enable the destructuring of values into smaller parts."}