{"question": "What is a lifetime in Rust?", "answer": "Every reference in Rust has a lifetime, which is the scope for which that reference is valid."}
{"question": "How are lifetimes usually handled in Rust?", "answer": "Most of the time, lifetimes are implicit and inferred, just like types are inferred."}
{"question": "When do we need to annotate lifetimes?", "answer": "We must annotate lifetimes when the lifetimes of references could be related in a few different ways."}
{"question": "What is the main purpose of lifetimes?", "answer": "The main aim of lifetimes is to prevent dangling references, which cause a program to reference data other than the data it’s intended to reference."}
{"question": "What is a dangling reference?", "answer": "A dangling reference occurs when a reference points to memory that has been deallocated, often because the data it was referencing went out of scope."}
{"question": "How does Rust prevent dangling references?", "answer": "Rust uses a borrow checker to compare scopes and determine whether all borrows are valid."}
{"question": "What does the borrow checker do?", "answer": "The borrow checker compares the lifetimes of references to ensure that a reference doesn't outlive the data it points to."}
{"question": "How do we annotate lifetimes?", "answer": "Lifetime annotations are placed after the `&` of a reference, using a space to separate the annotation from the reference’s type."}
{"question": "What is the syntax for lifetime annotations?", "answer": "Lifetime names must start with an apostrophe (`'`) and are usually all lowercase and very short, like generic types."}
{"question": "How do we declare generic lifetime parameters in function signatures?", "answer": "We declare generic lifetime parameters inside angle brackets between the function name and the parameter list."}
{"question": "What do lifetime annotations in function signatures specify?", "answer": "Lifetime annotations in function signatures describe the relationships of the lifetimes of multiple references to each other without affecting the lifetimes."}
{"question": "What happens when we pass concrete references to a function with lifetime annotations?", "answer": "The concrete lifetime that is substituted for the generic lifetime parameter is the part of the scope of the references that overlaps."}
{"question": "What is the lifetime elision rule?", "answer": "The lifetime elision rules are a set of particular cases that the compiler will consider, and if your code fits these cases, you don’t need to write the lifetimes explicitly."}
{"question": "What are the three lifetime elision rules?", "answer": "The first rule is that each parameter that is a reference gets its own lifetime parameter. The second rule is if there is exactly one input lifetime parameter, that lifetime is assigned to all output lifetime parameters. The third rule is if there are multiple input lifetime parameters, but one of them is `&self` or `&mut self` because this is a method, the lifetime of `self` is assigned to all output lifetime parameters."}
{"question": "What is the `'static` lifetime?", "answer": "The `'static` lifetime denotes the entire duration of the program."}
{"question": "What is the lifetime of string literals?", "answer": "All string literals have the `'static` lifetime."}
{"question": "How do we specify generic type parameters, trait bounds, and lifetimes together in a function?", "answer": "We declare the generic type parameters and lifetime parameters in the same list inside angle brackets after the function name, and we use a `where` clause to specify the trait bounds."}