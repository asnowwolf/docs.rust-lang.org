{"question": "What are generics used for in Rust?", "answer": "Generics allow you to create definitions for items like function signatures or structs that can be used with many different concrete data types, making your code more flexible and preventing code duplication."}
{"question": "How do you define a function using generics?", "answer": "Place the generics in the function signature where you would usually specify the data types of the parameters and return value."}
{"question": "What is the purpose of the `largest_i32` and `largest_char` functions in Listing 10-4?", "answer": "Both functions find the largest value in a slice, but `largest_i32` works with `i32` values, while `largest_char` works with `char` values."}
{"question": "How do you introduce a generic type parameter in a function definition?", "answer": "Declare the type parameter name inside angle brackets (`<>`) between the function name and the parameter list."}
{"question": "What is the convention for naming generic type parameters in Rust?", "answer": "The convention is to use a short name, often just a letter, and use CamelCase. The most common choice is `T` for \"type\"."}
{"question": "What does the error message \"binary operation `>` cannot be applied to type `T`\" indicate?", "answer": "It means that the body of the function cannot work for all possible types that `T` could be, because it requires comparing values of type `T`, which might not be possible for all types."}
{"question": "What is the `std::cmp::PartialOrd` trait, and how does it relate to the error message in Listing 10-5?", "answer": "The `std::cmp::PartialOrd` trait enables comparisons between values. The error message suggests that an implementation of this trait might be missing for the generic type `T`."}
{"question": "How do you define a struct using generics?", "answer": "Declare the generic type parameter name inside angle brackets (`<>`) just after the name of the struct, and then use the generic type in the struct definition where you would otherwise specify concrete data types."}
{"question": "What is the purpose of the `Point<T>` struct in Listing 10-6?", "answer": "It holds `x` and `y` coordinate values of any type `T`."}
{"question": "Why won't the code in Listing 10-7 compile?", "answer": "Because the `Point<T>` struct uses only one generic type parameter, both `x` and `y` must be of the same type, but the code attempts to assign an integer to `x` and a floating-point value to `y`."}
{"question": "How can you define a `Point` struct where `x` and `y` can be of different types?", "answer": "Use multiple generic type parameters, such as `T` and `U`, to define the struct as `Point<T, U>`."}
{"question": "What is the purpose of the `Option<T>` enum?", "answer": "It represents an optional value, allowing you to express the concept of having a value that might be present or absent, and it is generic so you can use it with any type."}
{"question": "What is the purpose of the `Result<T, E>` enum?", "answer": "It represents an operation that can either succeed (returning a value of type `T`) or fail (returning an error of type `E`)."}
{"question": "How do you implement methods on structs and enums using generics?", "answer": "Declare the generic type parameter name after `impl` so you can use it to specify that you're implementing methods on the generic type."}
{"question": "What is the difference between implementing methods on `Point<T>` and `Point<f32>`?", "answer": "Implementing methods on `Point<T>` makes them available for all instances of `Point` with any type `T`, while implementing methods on `Point<f32>` restricts them to instances of `Point` where `T` is specifically `f32`."}
{"question": "What is the purpose of the `mixup` method in Listing 10-11?", "answer": "It takes another `Point` as a parameter, which might have different types than the `self` `Point`, and creates a new `Point` instance with the `x` value from the `self` `Point` and the `y` value from the passed-in `Point`."}
{"question": "How does Rust ensure that code using generics doesn't run slower than code using concrete types?", "answer": "Rust performs monomorphization at compile time, which means it turns generic code into specific code by filling in the concrete types used in each instance."}
{"question": "What is monomorphization?", "answer": "It is the process of turning generic code into specific code by filling in the concrete types used when compiled."}
{"question": "How does monomorphization work in the context of the `Option<T>` enum?", "answer": "The compiler identifies the concrete types used in `Option<T>` instances (e.g., `i32` and `f64`) and expands the generic definition into specific definitions like `Option_i32` and `Option_f64`, replacing the generic definition with specific ones."}
{"question": "What is the benefit of monomorphization for performance?", "answer": "It ensures that there is no runtime cost for using generics, as the code runs just as it would if each definition had been duplicated by hand."}